package com.github.donovan_dead.Actions;

import java.awt.image.BufferedImage;
import java.util.Stack;

import com.github.donovan_dead.Utils.ImageUtils;

/**
 * The `ActionExecutioner` class manages and executes a sequence of image manipulation actions.
 * It provides functionality to add actions, undo/redo actions, and apply them to an image.
 */
public class ActionExecutioner {
    /** A stack to store the actions to be applied to the image. */
    private Stack<Actionable> actions;
    /** A stack to store actions that have been undone, allowing for reapplication. */
    private Stack<Actionable> undoneActions;

    /** The last `BufferedImage` result after executing all current actions. */
    private BufferedImage lastImg;
    /** The initial `BufferedImage` before any actions are applied. */
    private BufferedImage initImage;

    /**
     * Constructs a new `ActionExecutioner` with an initial image.
     *
     * @param init The initial `BufferedImage` to start applying actions on.
     */
    public ActionExecutioner( BufferedImage init){
        actions = new Stack<Actionable>();
        undoneActions = new Stack<Actionable>();

        initImage = init;
        lastImg = init;
    }

    /**
     * Adds an `Actionable` action to the stack of actions to be executed.
     *
     * @param action The `Actionable` instance to add.
     */
    public void addAction(Actionable action){
        actions.add(action);
    }

    /**
     * Sets a new initial image, clearing all previously recorded actions and undone actions.
     *
     * @param img The new `BufferedImage` to set as the initial image.
     */
    public void setNewImage(BufferedImage img){
        initImage = img;
        lastImg = img;
        clearActions();
        undoneActions.clear();
    }
    
    /**
     * Re-adds the last undone action back to the action stack, effectively redoing it.
     * If there are no undone actions, this method does nothing.
     */
    public void  regainLostAction(){
        if(undoneActions.empty()) return;
    
        actions.add(undoneActions.peek());
        undoneActions.pop();
    }

    /**
     * Removes the last action from the action stack and moves it to the undone actions stack,
     * effectively undoing it. If there are no actions to undo, this method does nothing.
     */
    public void popAction(){
        if(actions.empty()) return;
        
        undoneActions.add(actions.peek());
        actions.pop();
    }

    /**
     * Clears all current actions by moving them to the undone actions stack.
     */
    public void clearActions(){
        while (!actions.isEmpty()) { 
            undoneActions.add(actions.peek());
            actions.pop();
        }
    }

    /**
     * Executes all actions currently in the stack on a deep copy of the initial image.
     * The result is stored as `lastImg`.
     *
     * @return The `BufferedImage` after all actions have been applied, or `null` if `initImage` is `null`.
     */
    public BufferedImage executeActions(){
        if (initImage == null) return null;
        BufferedImage current = ImageUtils.deepCopy(initImage);

        for(Actionable a : actions){
            current = a.ApplyAction(current);
        }

        lastImg = current;
        return lastImg;
    }

    /**
     * Returns the last `BufferedImage` that was generated by `executeActions()`.
     *
     * @return The most recently processed `BufferedImage`.
     */
    public BufferedImage getLastImage(){
        return lastImg;
    }
}
